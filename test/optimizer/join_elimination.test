# name: test/optimizer/join_elimination.test
# description: Test whether the reduant join can be removed
# group: [optimizer]

require parquet

statement ok
PRAGMA explain_output = OPTIMIZED_ONLY;

statement ok
pragma enable_verification

statement ok
create table t(a int);

statement ok
create table t1(a int unique, b int, c int, d int, unique(b, c));

statement ok
create table t2(a int primary key, b int, c int, d int, unique(c, d));

statement ok
insert into t (select range as a from range(1000));

statement ok
insert into t1 (select range as a, a*2, a*3, a*4 from range(1000));

statement ok
insert into t2 (select range+100 as a, a*2+100, a*3+1000, a*4+1000 from range(1000));

# generate the parquet for tests
statement ok
COPY t1 TO '__TEST_DIR__/t1.parquet';

statement ok
CREATE view tp1 AS SELECT * FROM read_parquet('__TEST_DIR__/t1.parquet');

statement ok
COPY t2 TO '__TEST_DIR__/t2.parquet';

statement ok
CREATE view tp2 AS SELECT * FROM read_parquet('__TEST_DIR__/t2.parquet');

query II
explain select t1.* from t1 left join t2 on t1.b = t2.a;
----
logical_opt	<!REGEX>:.*JOIN.*

query II
explain select t1.* from t1 left join t2 on t1.b = t2.c and t1.d = t2.d;
----
logical_opt	<!REGEX>:.*JOIN.*

query II
explain select t1.* from t1 left join t2 on t1.a = t2.a and t1.b = t2.c and t1.d = t2.d;
----
logical_opt	<!REGEX>:.*JOIN.*

query II
explain select t1.* from t1 left join t2 on t1.d = t2.b and t1.b = t2.c and t1.c = t2.d;
----
logical_opt	<!REGEX>:.*JOIN.*

query II
explain select t2.* from t1 right join t2 on t2.b = t1.a;
----
logical_opt	<!REGEX>:.*JOIN.*

query II
explain select t2.* from t1 right join t2 on t1.b = t2.b and t2.c = t1.c;
----
logical_opt	<!REGEX>:.*JOIN.*

query II
explain select t2.* from t1 right join t2 on t1.a = t2.a and t1.b = t2.c and t2.b = t1.c;
----
logical_opt	<!REGEX>:.*JOIN.*

# The outer join in the following cases can not be removed

# There are some columns from the inner table have been used.
query II
explain select t2.a from t1 left join t2 on t1.b = t2.a;
----
logical_opt	<REGEX>:.*JOIN.*

# The keys in the inner side have not been fully covered by the unique index.
query II
explain select t2.a from t1 left join t2 on t1.b = t2.c;
----
logical_opt	<REGEX>:.*JOIN.*

# There are non column reference in the join keys
query II
explain select t1.* from t1 left join t2 on t1.b = t2.a+1;
----
logical_opt	<REGEX>:.*JOIN.*

# There are non column reference in the join keys
query II
explain select t1.* from t1 left join t2 on t1.b+1 = t2.a;
----
logical_opt	<REGEX>:.*JOIN.*

# The join conditions are not all equal conditions.
query II
explain select t1.* from t1 left join t2 on t1.b > t2.a;
----
logical_opt	<REGEX>:.*JOIN.*

# inner table contains inner join
query II
explain select t.a from t left join (t1 join t2 on t1.b = t2.b) on t1.a=t.a and t2.a=t.a;
----
logical_opt	<!REGEX>:.*JOIN.*

# inner table contains left join
query II
explain select t.* from t left join (t1 left join t2 on t2.a=t1.b) on t1.a=t.a;
----
logical_opt	<!REGEX>:.*JOIN.*

# one side is parquet file
query II
explain select t1.* from t1 left join tp2 as t2 on t1.b = t2.a;
----
logical_opt	<REGEX>:.*JOIN.*

query II
explain select t1.* from t1 left join tp2 as t2 on t1.b = t2.c and t1.d = t2.d;
----
logical_opt	<REGEX>:.*JOIN.*

query II
explain select t1.* from t1 left join tp2 as t2 on t1.a = t2.a and t1.b = t2.c and t1.d = t2.d;
----
logical_opt	<REGEX>:.*JOIN.*

query II
explain select t1.* from tp1 as t1 left join t2 on t1.b = t2.a;
----
logical_opt	<!REGEX>:.*JOIN.*

query II
explain select t1.* from tp1 as t1 left join t2 on t1.b = t2.c and t1.d = t2.d;
----
logical_opt	<!REGEX>:.*JOIN.*

query II
explain select t1.* from tp1 as t1 left join t2 on t1.a = t2.a and t1.b = t2.c and t1.d = t2.d;
----
logical_opt	<!REGEX>:.*JOIN.*

# check the output of the join
statement ok
select t1.* from t1 left join t2 on t1.b = t2.a;

statement ok
select t1.* from t1 left join t2 on t1.b = t2.c and t1.d = t2.d;

statement ok
select t1.* from t1 left join t2 on t1.a = t2.a and t1.b = t2.c and t1.d = t2.d;

statement ok
select t1.* from t1 left join t2 on t1.d = t2.b and t1.b = t2.c and t1.c = t2.d;

statement ok
select t2.* from t1 right join t2 on t2.b = t1.a;

statement ok
select t2.* from t1 right join t2 on t1.b = t2.b and t2.c = t1.c;

statement ok
select t2.* from t1 right join t2 on t1.a = t2.a and t1.b = t2.c and t2.b = t1.c;

statement ok
select t.a from t left join (t1 join t2 on t1.b = t2.b) on t1.a=t.a and t2.a=t.a;

statement ok
select t.* from t left join (t1 left join t2 on t2.a=t1.b) on t1.a=t.a;

statement ok
select t1.* from tp1 as t1 left join t2 on t1.b = t2.a;

statement ok
select t1.* from tp1 as t1 left join t2 on t1.b = t2.c and t1.d = t2.d;

statement ok
select t1.* from tp1 as t1 left join t2 on t1.a = t2.a and t1.b = t2.c and t1.d = t2.d;